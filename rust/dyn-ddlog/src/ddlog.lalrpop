// TODO: String & node interning
// TODO: It could be worth it to eventually use a custom lexer
//       with lalrpop, probably logos
//       https://lalrpop.github.io/lalrpop/lexer_tutorial/002_writing_custom_lexer.html#writing-a-custom-lexer
//       https://crates.io/crates/logos
// TODO: Error tolerant parsing so we can output multiple errors to the user
// TODO: Write the .dat parser here so it can share code

use crate::ast::{
    Attribute, Declaration, DeclarationKind, Expr, Fact, Function, Ident, Path, Literal,
    Relation, RelationKind, Rule, RuleClause, RuleHead, Type,
};
// TODO: Use custom error type
use lalrpop_util::ParseError;

grammar;

pub Datalog = Decl*;


Decl: Declaration<Ident> = <attrs: Attributes*> <decl: DeclKind>
    => Declaration::new(attrs.into_iter().flatten().collect(), decl);

DeclKind: DeclarationKind<Ident> = {
    Relation => DeclarationKind::Relation(<>),
    Rule => DeclarationKind::Rule(<>),
    Fact => DeclarationKind::Fact(<>),
    Function => DeclarationKind::Function(<>),
};

Attributes: Vec<Attribute<Ident>> = "#[" <attrs: Comma<(VariableIdent ("=" <Expr>)?)>> "]"
    => attrs.into_iter().map(|(ident, value)| Attribute::new(ident, value)).collect();


Relation: Relation<Ident> =
    <kind: RelationKind?> "relation" <ident: RelationIdent> "(" <args: RelationArgs> ")" => {
        let kind = kind.unwrap_or(RelationKind::Internal);

        Relation::new(kind, ident, args)
    };

RelationArgs: Vec<(Ident, Type<Ident>)> = Comma<(<LowercaseIdent> ":" <Type>)>;

RelationKind: RelationKind = {
    "input" => RelationKind::Input,
    "output" => RelationKind::Output,
};


Rule: Rule<Ident> =
    <head: Comma<RuleHead>> ":-" <clauses: Comma<RuleAtom>> "."
        => Rule::new(head, clauses);

RuleHead: RuleHead<Ident> =
    <name: RelationIdent> "(" <fields: Comma<Expr>> ")"
        => RuleHead::new(name, fields);

RuleAtom: RuleClause<Ident> = {
    RelationBinding,
    "not" <RelationBinding> => RuleClause::negated(<>),
    Expr => RuleClause::Expr(<>),
};

RelationBinding: RuleClause<Ident> =
    <binding: (<VariableIdent> "in")?> <relation: RelationIdent> "(" <fields: Comma<Expr>> ")"
        => RuleClause::relation(binding, relation, fields);


Fact: Fact<Ident> = <head: Comma<RuleHead>> "."
    => Fact::new(head);


Function: Function<Ident> =
    "function" <name: FuncPath> "(" <args: Comma<(<VariableIdent> ":" <Type>)>> ")" <ret: (":" <Type>)?> "{"
        <body: Semicolon<Expr>>
    "}"
    => Function::new(name, args, ret.unwrap_or(Type::Unit), Expr::block(body));


Type: Type<Ident> = {
    "bool" => Type::Bool,
    "string" => Type::String,
    "bigint" => Type::BigInt,
    "double" => Type::Double,
    "float" => Type::Float,

    "bit" "<" <width: r"[0-9][0-9_]*"> ">" =>? {
        width.parse::<u16>()
            // TODO: Better error message
            .map_err(|_| ParseError::User {
                error: "number is too big",
            })
            .map(Type::BitVec)
    },

    "signed" "<" <width: r"[0-9][0-9_]*"> ">" =>? {
        width.parse::<u16>()
            // TODO: Better error message
            .map_err(|_| ParseError::User {
                error: "number is too big",
            })
            .map(Type::Signed)
    },

    "(" <elems:  Comma<Type>> ")" => {
        if elems.is_empty() {
            Type::Unit
        } else {
            Type::Tuple(elems)
        }
    },

    <path: TypePath> <generics: ("<" <Comma<Type>> ">")?> => Type::Named {
        path,
        generics: generics.unwrap_or_default(),
    },
};


Expr: Expr<Ident> = {
    #[precedence(level = "0")]
    // TODO: This really shouldn't be an expression,
    //       it can trivially be an `.is_wildcard()`
    //       method on idents
    "_" => Expr::wildcard(),

    "(" <ExprReset> ")" => Expr::nested(<>).simplify_nesting(),
    "{" <Semicolon<ExprReset>> "}" => Expr::block(<>).simplify_blocks(),

    VariableIdent => Expr::ident(<>),
    Literal => Expr::literal(<>),

    "if" "(" <cond: ExprReset> ")" "{" <then: Semicolon<ExprReset>> "}" <else_: ("else" "{" <Semicolon<ExprReset>> "}")?>
        => Expr::if_(cond, Expr::block(then), Expr::block(else_.unwrap_or_default())),

    #[precedence(level = "1")]
    #[assoc(side = "right")]
    "-" <Expr> => Expr::neg(<>),
    "not" <Expr> => Expr::not(<>),
    "~" <Expr> => Expr::bit_not(<>),

    "return" <Expr> => Expr::ret(Some(<>)),
    "break" <Expr> => Expr::brk(Some(<>)),
    "continue" <Expr> => Expr::cont(Some(<>)),

    #[precedence(level = "2")]
    #[assoc(side = "left")]
    <lhs: Expr> "*" <rhs: Expr> => Expr::mul(lhs, rhs),
    <lhs: Expr> "/" <rhs: Expr> => Expr::div(lhs, rhs),
    <lhs: Expr> "%" <rhs: Expr> => Expr::rem(lhs, rhs),

    #[precedence(level = "3")]
    #[assoc(side = "left")]
    <lhs: Expr> "+" <rhs: Expr> => Expr::add(lhs, rhs),
    <lhs: Expr> "-" <rhs: Expr> => Expr::sub(lhs, rhs),

    #[precedence(level = "4")]
    #[assoc(side = "left")]
    <lhs: Expr> ">>" <rhs: Expr> => Expr::shr(lhs, rhs),
    <lhs: Expr> "<<" <rhs: Expr> => Expr::shl(lhs, rhs),

    #[precedence(level = "5")]
    #[assoc(side = "left")]
    <lhs: Expr> ">" <rhs: Expr> => Expr::greater(lhs, rhs),
    <lhs: Expr> "<" <rhs: Expr> => Expr::less(lhs, rhs),
    <lhs: Expr> ">=" <rhs: Expr> => Expr::greater_equal(lhs, rhs),
    <lhs: Expr> "<=" <rhs: Expr> => Expr::less_equal(lhs, rhs),

    #[precedence(level = "6")]
    #[assoc(side = "left")]
    <lhs: Expr> "==" <rhs: Expr> => Expr::equal(lhs, rhs),
    <lhs: Expr> "!=" <rhs: Expr> => Expr::not_equal(lhs, rhs),

    #[precedence(level = "7")]
    #[assoc(side = "left")]
    <lhs: Expr> "&" <rhs: Expr> => Expr::bit_and(lhs, rhs),

    #[precedence(level = "8")]
    #[assoc(side = "left")]
    <lhs: Expr> "|" <rhs: Expr> => Expr::bit_or(lhs, rhs),

    #[precedence(level = "9")]
    #[assoc(side = "left")]
    <lhs: Expr> "and" <rhs: Expr> => Expr::and(lhs, rhs),

    #[precedence(level = "10")]
    #[assoc(side = "left")]
    <lhs: Expr> "or" <rhs: Expr> => Expr::or(lhs, rhs),

    #[precedence(level = "11")]
    #[assoc(side = "left")]
    <lhs: Expr> "++" <rhs: Expr> => Expr::concat(lhs, rhs),

    #[precedence(level = "12")]
    "return" => Expr::ret(None),
    "break" => Expr::brk(None),
    "continue" => Expr::cont(None),
};

// FIXME: Lalrpop dosen't reset precedence levels for nested stuff
//        so we have to do it manually.
//        See https://github.com/lalrpop/lalrpop/issues/596
ExprReset = <Expr>;

Literal: Literal = {
    r"[0-9][0-9_]*" =>? {
        <>.parse::<u64>()
            // TODO: Better error message
            .map_err(|_| ParseError::User {
                error: "number is too big",
            })
            .map(Literal::Int)
    },

    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};


FuncPath = LowercasePath;
TypePath: Path<Ident> = Path<Ident> => Path::new(<>);
LowercasePath: Path<Ident> = Path<LowercaseIdent> => Path::new(<>);

Ident = { UppercaseIdent, LowercaseIdent };
VariableIdent = LowercaseIdent;
RelationIdent = UppercaseIdent;

LowercaseIdent: Ident = r"[a-z_][a-zA-Z0-9_]*" => Ident::lowercase(<>.to_owned());
UppercaseIdent: Ident = r"[A-Z][a-zA-Z0-9_]*" => Ident::uppercase(<>.to_owned());


/// Parse a comma separated list of items into a vec,
/// allowing trailing commas or zero elements
Comma<T>: Vec<T> = {
    <head: (<T> ",")*> <tail: T?> => match tail {
        None => head,
        Some(tail) => {
            let mut head = head;
            head.reserve(1);
            head.push(tail);

            head
        }
    }
};

/// Parse a `::` separated list of items into a vec
Path<T>: Vec<T> = {
    <head: (<T> "::")*> <tail: T> => {
        let mut head = head;
        head.reserve(1);
        head.push(tail);

        head
    }
}

/// Parse a semicolon separated list of items into a vec,
/// allowing trailing semicolons or zero elements
Semicolon<T>: Vec<T> = {
    <head: (<T> ";")*> <tail: T?> => match tail {
        None => head,
        Some(tail) => {
            let mut head = head;
            head.reserve(1);
            head.push(tail);

            head
        }
    }
};


match {
    // The default whitespace skipping is disabled when an `ignore pattern` is specified,
    // so we re-enable it
    r"\s*" => { },
    // Skip single line comments a la `// comments`
    r"//[^\n\r]*[\n\r]*" => { },
    // Skip multi line comments a la `/* comments */`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },

    // Register all of our keywords
    "relation" => "relation",
    "input" => "input",
    "output" => "output",
    "in" => "in",
    "and" => "and",
    "not" => "not",
    "or" => "or",
    "_" => "_",
    "bool" => "bool",
    "string" => "string",
    "bigint" => "bigint",
    "true" => "true",
    "false"=> "false",
    "function" => "function",
    "extern" => "extern",
    "return" => "return",

    "::" => "::",
} else {
    // We can safely ignore non-whitespace and non-comment
    // tokens and let them pass onto the rest of the parser
    _
}
