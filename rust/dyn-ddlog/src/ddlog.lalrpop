// TODO: String & node interning
// TODO: It could be worth it to eventually use a custom lexer
//       with lalrpop, probably logos
//       https://lalrpop.github.io/lalrpop/lexer_tutorial/002_writing_custom_lexer.html#writing-a-custom-lexer
//       https://crates.io/crates/logos
// TODO: Error tolerant parsing so we can output multiple errors to the user
// TODO: Write the .dat parser here so it can share code

use crate::ast::{
    Attribute, Declaration, DeclarationKind, Expr, Ident, Literal, Relation, RelationKind, Rule,
    RuleClause, RuleHead, Type, Function, IdentPath,
};
// TODO: Use custom error type
use lalrpop_util::ParseError;

grammar;

pub Datalog = Decl*;

Decl: Declaration = <attrs: Attributes*> <decl: DeclKind>
    => Declaration::new(attrs.into_iter().flatten().collect(), decl);

Attributes: Vec<Attribute> = "#[" <attrs: Comma<(VariableIdent ("=" <Expr>)?)>> "]"
    => attrs.into_iter().map(|(ident, value)| Attribute::new(ident, value)).collect();

DeclKind: DeclarationKind = {
    Relation => DeclarationKind::Relation(<>),
    Rule => DeclarationKind::Rule(<>),
    Function => DeclarationKind::Function(<>),
};

Relation: Relation =
    <kind: RelationKind?> "relation" <ident: RelationIdent> "(" <args: RelationArgs> ")" => {
        let kind = kind.unwrap_or(RelationKind::Internal);

        Relation::new(kind, ident, args)
    };

RelationArgs: Vec<(Ident, Type)> = Comma<(<LowercaseIdent> ":" <Type>)>;

RelationKind: RelationKind = {
    "input" => RelationKind::Input,
    "output" => RelationKind::Output,
};

Rule: Rule = <head: Comma<RuleHead>> ":-" <clauses: Comma<RuleAtom>> "."
    => Rule::new(head, clauses);

RuleHead: RuleHead = <name: RelationIdent> "(" <fields: Comma<Expr>> ")"
    => RuleHead::new(name, fields);

RuleAtom: RuleClause = {
    RelationBinding,
    "not" <RelationBinding> => RuleClause::negated(<>),
    Expr => RuleClause::Expr(<>),
};

RelationBinding: RuleClause =
    <binding: (<VariableIdent> "in")?> <relation: RelationIdent> "(" <fields: Comma<Expr>> ")"
        => RuleClause::relation(binding, relation, fields);

Function: Function =
    "function" <name: FuncPath> "(" <args: Comma<(<VariableIdent> ":" <Type>)>> ")" <ret: (":" <Type>)?> "{"
        <body: Semicolon<Expr>>
    "}"
    => Function::new(name, args, ret.unwrap_or(Type::Unit), Expr::block(body));

Type: Type = {
    "bigint" => Type::BigInt,
    "bool" => Type::Bool,
    "string" => Type::String,
    "(" ")" => Type::Unit,
};

Expr: Expr = {
    Term,
    <lhs: Expr> "and" <rhs: Term> => Expr::and(lhs, rhs),
    "-" <Term> => Expr::neg(<>),
    "~" <Term> => Expr::bit_not(<>),
    "not" <Term> => Expr::not(<>),
    <lhs: Expr> "*" <rhs: Term> => Expr::mul(lhs, rhs),
    <lhs: Expr> "/" <rhs: Term> => Expr::div(lhs, rhs),
    <lhs: Expr> "+" <rhs: Term> => Expr::add(lhs, rhs),
};

// Expression terminals
Term: Expr = {
    "_" => Expr::wildcard(),
    "(" <Expr> ")" => Expr::nested(<>),
    "{" <Semicolon<Expr>> "}" => Expr::block(<>),
    VariableIdent => Expr::ident(<>),
    Literal => Expr::literal(<>),
};

Literal: Literal = {
    r"[0-9][0-9_]*" =>? {
        <>.parse::<u128>()
            // TODO: Better error message
            .map_err(|_| ParseError::User {
                error: "number is too big",
            })
            .map(Literal::Int)
    },

    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

FuncPath = LowercasePath;
LowercasePath: IdentPath = Path<LowercaseIdent> => IdentPath::new(<>);

Ident = { UppercaseIdent, LowercaseIdent };
VariableIdent = LowercaseIdent;
RelationIdent = UppercaseIdent;

LowercaseIdent: Ident = r"[a-z_][a-zA-Z0-9_]*" => Ident::lowercase(<>.to_owned());
UppercaseIdent: Ident = r"[A-Z][a-zA-Z0-9_]*" => Ident::uppercase(<>.to_owned());

/// Parse a comma separated list of items into a vec,
/// allowing trailing commas or zero elements
Comma<T>: Vec<T> = {
    <head: (<T> ",")*> <tail: T?> => match tail {
        None => head,
        Some(tail) => {
            let mut head = head;
            head.reserve(1);
            head.push(tail);

            head
        }
    }
};

/// Parse a `::` separated list of items into a vec
Path<T>: Vec<T> = {
    <head: (<T> "::")*> <tail: T> => {
        let mut head = head;
        head.reserve(1);
        head.push(tail);

        head
    }
}

/// Parse a semicolon separated list of items into a vec,
/// allowing trailing semicolons or zero elements
Semicolon<T>: Vec<T> = {
    <head: (<T> ";")*> <tail: T?> => match tail {
        None => head,
        Some(tail) => {
            let mut head = head;
            head.reserve(1);
            head.push(tail);

            head
        }
    }
};

match {
    // The default whitespace skipping is disabled when an `ignore pattern` is specified,
    // so we re-enable it
    r"\s*" => { },
    // Skip single line comments a la `// comments`
    r"//[^\n\r]*[\n\r]*" => { },
    // Skip multi line comments a la `/* comments */`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },

    // Register all of our keywords
    "relation" => "relation",
    "input" => "input",
    "output" => "output",
    "in" => "in",
    "and" => "and",
    "not" => "not",
    "or" => "or",
    "_" => "_",
    "bool" => "bool",
    "string" => "string",
    "bigint" => "bigint",
    "true" => "true",
    "false"=> "false",
    "function" => "function",
    "extern" => "extern",

    "::" => "::",
} else {
    // We can safely ignore non-whitespace and non-comment
    // tokens and let them pass onto the rest of the parser
    _
}
