// TODO: String & node interning
// TODO: It could be worth it to eventually use a custom lexer
//       with lalrpop, probably logos
//       https://lalrpop.github.io/lalrpop/lexer_tutorial/002_writing_custom_lexer.html#writing-a-custom-lexer
//       https://crates.io/crates/logos
// TODO: Error tolerant parsing so we can output multiple errors to the user

use crate::ast::{
    Attribute, Declaration, DeclarationKind, Expr, Ident, Literal, Relation, RelationKind, Rule,
    RuleClause, RuleHead, Type,
};

grammar;

pub Datalog = Decl*;

Decl: Declaration = <attrs: Attributes*> <decl: DeclKind> =>
    Declaration::new(attrs.into_iter().flatten().collect(), decl);

Attributes: Vec<Attribute> = "#[" <attrs: Comma<(VariableIdent ("=" <Expr>)?)>> "]"
    => attrs.into_iter().map(|(ident, value)| Attribute::new(ident, value)).collect();

DeclKind: DeclarationKind = {
    Relation => DeclarationKind::Relation(<>),
    Rule => DeclarationKind::Rule(<>),
};

Relation: Relation =
    <kind: RelationKind?> "relation" <ident: RelationIdent> "(" <args: RelationArgs> ")" => {
        let kind = kind.unwrap_or(RelationKind::Internal);

        Relation::new(kind, ident, args)
    };

RelationArgs: Vec<(Ident, Type)> = Comma<(<LowercaseIdent> ":" <Type>)>;

RelationKind: RelationKind = {
    "input" => RelationKind::Input,
    "output" => RelationKind::Output,
};

Rule: Rule = <head: Comma<RuleHead>> ":-" <clauses: Comma<RuleAtom>> "."
    => Rule::new(head, clauses);

RuleHead: RuleHead = <name: RelationIdent> "(" <fields: Comma<Expr>> ")"
    => RuleHead::new(name, fields);

RuleAtom: RuleClause = {
    RelationBinding,
    "not" <RelationBinding> => RuleClause::negated(<>),
    Expr => RuleClause::Expr(<>),
};

RelationBinding: RuleClause =
    <binding: (<VariableIdent> "in")?> <relation: RelationIdent> "(" <fields: Comma<Expr>> ")"
        => RuleClause::relation(binding, relation, fields);

Type: Type = {
    "bigint" => Type::BigInt,
    "bool" => Type::Bool,
    "string" => Type::String,
};

Expr: Expr = {
    Term,
    <lhs: Expr> "and" <rhs: Term> => Expr::and(lhs, rhs),
    "-" <Term> => Expr::neg(<>),
    "~" <Term> => Expr::bit_neg(<>),
    "not" <Term> => Expr::not(<>),
    <lhs: Expr> "*" <rhs: Term> => Expr::mul(lhs, rhs),
};

// Expression terminals
Term: Expr = {
    "_" => Expr::wildcard(),
    "(" <Expr> ")" => Expr::parens(<>),
    "{" <Expr> "}" => Expr::parens(<>),
    VariableIdent => Expr::ident(<>),
    Literal => Expr::literal(<>),
};

Literal: Literal = {
    r"[0-9][0-9_]*" => Literal::Int(<>.parse().unwrap()),
    "true" => Literal::Bool(true),
    "false" => Literal::Bool(false),
};

Ident = { UppercaseIdent, LowercaseIdent };

VariableIdent = LowercaseIdent;
RelationIdent = UppercaseIdent;

LowercaseIdent: Ident = r"[a-z_][a-zA-Z0-9_]*" => Ident::lowercase(<>.to_owned());
UppercaseIdent: Ident = r"[A-Z][a-zA-Z0-9_]*" => Ident::uppercase(<>.to_owned());

/// Parse a comma separated list of items into a vec,
/// allowing trailing commas or zero elements
Comma<T>: Vec<T> = {
    <head: (<T> ",")*> <tail: T?> => match tail {
        None => head,
        Some(tail) => {
            let mut head = head;
            head.reserve(1);
            head.push(tail);

            head
        }
    }
};

match {
    // The default whitespace skipping is disabled when an `ignore pattern` is specified,
    // so we re-enable it
    r"\s*" => { },
    // Skip single line comments a la `// comments`
    r"//[^\n\r]*[\n\r]*" => { },
    // Skip multi line comments a la `/* comments */`
    r"/\*([^\*]*\*+[^\*/])*([^\*]*\*+|[^\*])*\*/" => { },

    // Register all of our keywords
    "relation" => "relation",
    "input" => "input",
    "output" => "output",
    "in" => "in",
    "and" => "and",
    "not" => "not",
    "or" => "or",
    "_" => "_",
    "bool" => "bool",
    "string" => "string",
    "bigint" => "bigint",
    "true" => "true",
    "false"=> "false",
} else {
    // We can safely ignore non-whitespace and non-comment
    // tokens and let them pass onto the rest of the parser
    _
}
